# java的编译与运行

1. 源文件为`xx.java`使用`javac xx.java`进行编译并生成`xx.class`文件
2. 执行`java xx`就可以运行编译后的`xx.class`文件
3. `javadoc -encoding UTF-8 -charset UTF-8 xx.java`生成对应的javadoc文档
4. 一个项目只有一个类中有面方法

## 定义变量

`数据类型 变量名`

类变量： `static 类型 数据名`

## 变量类型

* 基本数据类型
  * 数值类型
    * 整数类型(数值可以用`_`分割，不影响值，方便查看)
      * byte：占1字节；-128~127
      * short：占2字节；-32768~32767
      * int：占4字节；-21亿~21亿
      * long：占8字节；在数值后面加上`L`
    * 浮点数类型(由于二进制存储浮点数离散，如果对浮点数有较精确用整数代替)
      * float：占4字节；在数值后面加上`F`
      * double：占8字节
    * 字符类型(unicode编码)
      * char：占2字节；'\u0064'
  * 布尔类型：占1位只有true和false
* 引用数据类型
  * 类
  * 接口
  * 数组

字符串：String

### 进制表示

|二进制|八进制|十进制|十六进制|
|--|--|--|--|
|0b10(2)|010(8)|10|0x10(16)|

### 示例变量初始化

* 数值：0或者0.0
* 布尔：false
* 其他类型：null

### 类型转换

~~~java

低 ----------> 高
byte,short,char->int->long->float->double
~~~

运算中低到高自动转，高到低需要手动强制类型转换

* 强制类型转换`(类型)变量`
  * 布尔型不可以转
  * 存在内存溢出，精度丢失问题

* 变量计算结果类型默认int，如果输入中有long类型，那么就为long，浮点数也是

## 常量

`final 类型 常量名`

* 被final装饰的类就是常量类，没有子类

## 运算符号

++a：先自增再赋值
a++：先赋值再自增

## 字符串连接

""+10+20:"1020" (如果`+`号遇到字符串那么会把之后的所有`+`号都做拼接使用)
10+20+"":"30"

## 三元运算符 ？

a?b:c：如果a为真返回b，假返回c

## 包导入

和py一样，但是要在package之后

## 文档注释

* @author：作者
* @version：版本号
* @since：jdk版本
* @param：参数名
* @return：返回值情况
* @throws：异常抛出情况

## 用户交付类

~~~java

//定义Scanner类
Scanner s = new Scanner(System.in); 
//判断是否有输入值
if (s.hasNext()){
  //将输入值赋值给String对象
    String a = s.next();
    System.out.println(a);
}
//关闭Scanner类
s.close();
~~~

* hasNext()：判断是否输入值，忽略非空内容前空格，并将内容后空格进行回车处理。
  * netx()：获取输入内容，忽略非空内容前空格，并将内容后空格进行回车处理。
* hasNextLine()：判断是否输入内容，不对内容中的空格进行处理。
  * netLine()：获取输入内容

### 字符串是否相等

~~~java

//判断s变量是否和hello字符串一样
s.equals("hello")
~~~

## 控制流程

## 判断

`if(判断条件){语句}`

`if(判断条件){语句1}else{语句2}`

`if(条件1){语句1}else if(条件2){语句2}else{语句3}`

`witch(值/字符){case 值1 :语句1;break;case 值2 :语句2;break;default :语句3;}`

## 循环

`while(条件){语句}`

`do{语句}while(条件)`

`for(初始;条件;更新){语句}`

`for(定义变量:可迭代对象){语句}`

## 方法

`修饰符 返回值类型(空就是void) 函数名(参数类型 形参){函数体}`

## 重载

* 需要在同一个类中有多个同名函数
* 且多个同名函数行参不一致(数量,类型,顺序)

调用时会对多个同名函数进行一个一个匹配，如果最后都不匹配则报错

## 命令行传参

* 先编译java文件为class文件
* 如果class文件结构在包文件中，运行时`java 包路径\class文件 传递参数`

## 数组

定义并赋值
`数据类型[] 变量名 = new 数据类型[数组大小]`或者
`数据类型 变量名[]=new 数据类型[数组大小]}`或
`数据类型[] 变量名 = {内容用逗号隔开}`

查看数组大小 `数组变量名.length`

## 多维数组

`数据类型[][] 变量名={{},{}}`

## 离散数组

对一个数组中大部分元素为0或者重复值时使用离散数组进行压缩存储

离散数组就是一个较小的二维数组，记录原数组的大小与不同值的个数，不同值的坐标

0 0 0——————> 3 3 1
0 2 0        1 1 2
0 0 0

## 对象

修饰符：

* static：静态(可以不实例化直接使用`类名称.方法名()`调用)
  * 和类一起加载的，如果在其中调用非静态方法，则会出现静态方法未加载。报错
* default：默认

* public：公开；所有位置都可以访问(一个java文件只能有一个类被`public`修饰)
* private：私有；无法继承，只能被本类中访问
* 缺省：本类可以，同包可以
* protected(受保护的)：同包下或者子类可以访问

## 类

~~~java

// Student类继承Person类
// 继承只有单继承
public class Student extends Person{
  //属性
  属性类型 属性名称

  //类的同名方法为构造方法，构造方法可隐藏
  //写有参构造器行必须同时也写一个无参构造器，写了有参，隐藏的无参就无效了
  public Student(){
    //存在隐藏代码`super();`，并且父类构造器在子类构造器前执行

  }

  //方法
  public void study(){
    return 
  }
}

~~~

* this == self

## 多态

~~~java

//可以调用自己和继承的方法
Student s1 = new Student()
//父类指向子类，不可以调用子类独有的方法和属性，调用的方法是子类方法
Person s2= new Student()

/**
* 两个方面理解，第一在编译阶段，在编译器中s2为Person类型，所以只能调用Person定义的方法。
* 在程序运行是实际s2中存储的对象是Student实例，所以执行方法结果和与Student类一致，及方法重载后的结果。
*/
~~~

~~~java

//定义动物类，并有方法吃（吃东西）
//定义猴子类是动物类子类，并重写方法吃（吃香蕉）
//定义狗类是动物类的子类，并重写方法吃（吃骨头）

动物 a = new 猴子();
动物 b = new 狗();

//a和b对象都是动物类但是执行吃时结果不一样,形成同种类执行相同方法但结果不同
a.吃();
//吃香蕉
b.吃();
//吃骨头
~~~

## 代码块

~~~java

{匿名代码块}
static {静态代码块}
~~~

匿名代码块：在实例化代码时执行，一般用于设置初始值
静态代码块：在加载类时执行一次，后续实例化不执行

## 抽象类

~~~java

//抽象类；不可以new，可以有正常的属性和方法；
public abstract class Dome{

// 抽象方法；抽象方法必须在抽象类中，抽象类中可以没有抽象方法;不写方法体，结构体有非抽象子类重写方法
  public abstract int get(int i);
}

class DomIn extends Dome{
  //提示编译器下面方法为重写方法
  @Override
  public int get(int i){
    System.out.println("重写的方法")
  }

}
~~~

* abstract：抽象
* 抽象类对非抽象子类强制与规范作用
  * 强制：方法重写
  * 规范：重写方法的方法名，返回值，形参类型与个都要与父类中方法一致

## 接口

~~~java

//接口中属性只能是常量，方法也只能是抽象方法
public interface Inter{
  public static final int I = 5;
  public abstract void show();
}

//接口可以被接口继承并且是多继承,多继承用逗号隔开 
public interface InteA extends Inter,Inter2 {
  public abstract void show2();
}


//但是接口最后都要由类实现，并且可以实现多个接口
public class inc implements InteA,Inter {
  //重写接口方法
  @Override
  public void show(){
    System.out.println("00000")
  }
}
~~~

* interface：接口
* implements：接口实现

~~~java

语法：
接口/父类类型 引用名 = new 接口/父类类型(){方法重写}

===============================================

实际效果：
实现接口的类/父类的子类{
  方法重写
}
接口/父类类型 引用名 = new 实现接口的类/父类的子类

~~~

## 异常

~~~java

try{
  可能报错语句
} catch(异常类型 变量名){
  异常处理语句
} finally{
  报不报错都执行语句
}


//抛出异常 在方法中使用;如果方法用throws关键字那么异常会被返回
throw nwe  异常类型()  
~~~

## 常用包

## object

* 所有类是基类
* toString()
  * 返回类名称与实例的内存地址
  * 所有子类都应该重写这个方法
  * 可以只用`对象.toString()`调用也可以使用`对象`调用返回值
* hascode()
  * 返回对象内存地址的哈希值
* equals()
  * 判断两个对象是否相等，返回布尔量
  * 需要就重写，默认判断内存地址是否一致
* finalize()
  *对象被垃圾回收时执行的语句，类似静态代码块
* clone()
  * 克隆对象，有深克隆和浅克隆
  